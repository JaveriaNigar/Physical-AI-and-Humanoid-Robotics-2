"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_textbook=self.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[479],{1470:(e,n,r)=>{r.d(n,{A:()=>z});var i=r(6540),s=r(4164),a=r(7559),l=r(3104),t=r(6347),o=r(205),d=r(7485),c=r(1682),m=r(679);function h(e){var n,r;return null!=(n=null==(r=i.Children.toArray(e).filter(function(e){return"\n"!==e}).map(function(e){if(!e||(0,i.isValidElement)(e)&&((n=e.props)&&"object"==typeof n&&"value"in n))return e;var n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))?void 0:r.filter(Boolean))?n:[]}function u(e){var n=e.values,r=e.children;return(0,i.useMemo)(function(){var e=null!=n?n:function(e){return h(e).map(function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}})}(r);return function(e){var n=(0,c.XI)(e,function(e,n){return e.value===n.value});if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map(function(e){return e.value}).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e},[n,r])}function x(e){var n=e.value;return e.tabValues.some(function(e){return e.value===n})}function p(e){var n=e.queryString,r=void 0!==n&&n,s=e.groupId,a=(0,t.W6)(),l=function(e){var n=e.queryString,r=void 0!==n&&n,i=e.groupId;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=i?i:null}({queryString:r,groupId:s});return[(0,d.aZ)(l),(0,i.useCallback)(function(e){if(l){var n=new URLSearchParams(a.location.search);n.set(l,e),a.replace(Object.assign({},a.location,{search:n.toString()}))}},[l,a])]}function g(e){var n,r,s,a,l=e.defaultValue,t=e.queryString,d=void 0!==t&&t,c=e.groupId,h=u(e),g=(0,i.useState)(function(){return function(e){var n,r=e.defaultValue,i=e.tabValues;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!x({value:r,tabValues:i}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+r+'" but none of its children has the corresponding value. Available values are: '+i.map(function(e){return e.value}).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return r}var s=null!=(n=i.find(function(e){return e.default}))?n:i[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:l,tabValues:h})}),j=g[0],f=g[1],b=p({queryString:d,groupId:c}),y=b[0],v=b[1],_=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:c}.groupId),r=(0,m.Dv)(n),s=r[0],a=r[1],[s,(0,i.useCallback)(function(e){n&&a.set(e)},[n,a])]),z=_[0],w=_[1],R=function(){var e=null!=y?y:z;return x({value:e,tabValues:h})?e:null}();return(0,o.A)(function(){R&&f(R)},[R]),{selectedValue:j,selectValue:(0,i.useCallback)(function(e){if(!x({value:e,tabValues:h}))throw new Error("Can't select invalid tab value="+e);f(e),v(e),w(e)},[v,w,h]),tabValues:h}}var j=r(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=r(4848);function y(e){var n=e.className,r=e.block,i=e.selectedValue,a=e.selectValue,t=e.tabValues,o=[],d=(0,l.a_)().blockElementScrollPositionUntilNextRender,c=function(e){var n=e.currentTarget,r=o.indexOf(n),s=t[r].value;s!==i&&(d(n),a(s))},m=function(e){var n,r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":var i,s=o.indexOf(e.currentTarget)+1;r=null!=(i=o[s])?i:o[0];break;case"ArrowLeft":var a,l=o.indexOf(e.currentTarget)-1;r=null!=(a=o[l])?a:o[o.length-1]}null==(n=r)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":r},n),children:t.map(function(e){var n=e.value,r=e.label,a=e.attributes;return(0,b.jsx)("li",Object.assign({role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:function(e){o.push(e)},onKeyDown:m,onClick:c},a,{className:(0,s.A)("tabs__item",f.tabItem,null==a?void 0:a.className,{"tabs__item--active":i===n}),children:null!=r?r:n}),n)})})}function v(e){var n=e.lazy,r=e.children,a=e.selectedValue,l=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){var t=l.find(function(e){return e.props.value===a});return t?(0,i.cloneElement)(t,{className:(0,s.A)("margin-top--md",t.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:l.map(function(e,n){return(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a})})})}function _(e){var n=g(e);return(0,b.jsxs)("div",{className:(0,s.A)(a.G.tabs.container,"tabs-container",f.tabList),children:[(0,b.jsx)(y,Object.assign({},n,e)),(0,b.jsx)(v,Object.assign({},n,e))]})}function z(e){var n=(0,j.A)();return(0,b.jsx)(_,Object.assign({},e,{children:h(e.children)}),String(n))}},8149:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"chapters/ch4-sim","title":"Chapter 4: Digital Twin Simulation with Gazebo","description":"Master physics simulation, sensor modeling, and sim-to-real transfer for humanoid robotics using Gazebo and URDF.","source":"@site/docs/chapters/ch4-sim.mdx","sourceDirName":"chapters","slug":"/chapters/ch4-sim","permalink":"/docs/chapters/ch4-sim","draft":false,"unlisted":false,"editUrl":"https://github.com/Danishhshahid/Physical-AI-Humanoid-Robotics-Book/tree/main/website/docs/chapters/ch4-sim.mdx","tags":[],"version":"current","frontMatter":{"id":"ch4-sim","title":"Chapter 4: Digital Twin Simulation with Gazebo","sidebar_label":"Ch4: Simulation","description":"Master physics simulation, sensor modeling, and sim-to-real transfer for humanoid robotics using Gazebo and URDF.","keywords":["gazebo","urdf","simulation","digital twin","sim-to-real","physics engine","sensor simulation","domain randomization"],"image":"/img/ch4-sim-hero.png"}}');var s=r(4848),a=r(8453),l=r(1470),t=r(9365);const o={id:"ch4-sim",title:"Chapter 4: Digital Twin Simulation with Gazebo",sidebar_label:"Ch4: Simulation",description:"Master physics simulation, sensor modeling, and sim-to-real transfer for humanoid robotics using Gazebo and URDF.",keywords:["gazebo","urdf","simulation","digital twin","sim-to-real","physics engine","sensor simulation","domain randomization"],image:"/img/ch4-sim-hero.png"},d=void 0,c={},m=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"4.1 What is a Digital Twin?",id:"41-what-is-a-digital-twin",level:2},{value:"Definition and Purpose",id:"definition-and-purpose",level:3},{value:"The Sim-to-Real Gap",id:"the-sim-to-real-gap",level:3},{value:"4.2 URDF Robot Models",id:"42-urdf-robot-models",level:2},{value:"URDF Overview",id:"urdf-overview",level:3},{value:"URDF Structure",id:"urdf-structure",level:3},{value:"Example: 2-DOF Arm URDF",id:"example-2-dof-arm-urdf",level:3},{value:"4.3 Gazebo Simulation Environment",id:"43-gazebo-simulation-environment",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:3},{value:"Setting Up Gazebo",id:"setting-up-gazebo",level:3},{value:"Gazebo World File (SDF Format)",id:"gazebo-world-file-sdf-format",level:3},{value:"4.4 Sensor Simulation in Gazebo",id:"44-sensor-simulation-in-gazebo",level:2},{value:"Overview",id:"overview",level:3},{value:"Simulating an IMU Sensor",id:"simulating-an-imu-sensor",level:3},{value:"Simulating a Camera",id:"simulating-a-camera",level:3},{value:"4.5 Sim-to-Real Transfer via Domain Randomization",id:"45-sim-to-real-transfer-via-domain-randomization",level:2},{value:"The Reality Gap Problem",id:"the-reality-gap-problem",level:3},{value:"Implementation: Randomize Physics Parameters",id:"implementation-randomize-physics-parameters",level:3},{value:"Evaluating Sim-to-Real Success",id:"evaluating-sim-to-real-success",level:3},{value:"4.6 Embodiment Challenge: Sim-to-Real Grasping",id:"46-embodiment-challenge-sim-to-real-grasping",level:2},{value:"4.7 References",id:"47-references",level:2},{value:"4.8 RAG Integration Hooks",id:"48-rag-integration-hooks",level:2},{value:"Chapter Summary",id:"chapter-summary",level:2}];function h(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Describe digital twin architecture"})," and its role in reducing real-world testing risk"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write URDF models"})," to represent robot structure, joints, and physics properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configure Gazebo simulators"})," with physics engines, sensors, and environmental factors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement sensor simulation"})," (camera, IMU, force/torque) within Gazebo"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Apply domain randomization techniques"})," to bridge the sim-to-real gap"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evaluate sim-to-real transfer success"})," using quantitative metrics"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Key Concept",type:"info",children:(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"digital twin"})," is a physics-accurate virtual replica of a robot that enables safe, fast iteration before deploying to hardware. Simulation accelerates learning-based control development by 10-100\xd7 versus real-world training alone."]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"41-what-is-a-digital-twin",children:"4.1 What is a Digital Twin?"}),"\n",(0,s.jsx)(n.h3,{id:"definition-and-purpose",children:"Definition and Purpose"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"digital twin"})," is a computationally faithful model of a physical robot that replicates its kinematics, dynamics, sensors, and environment in a virtual world. The digital twin serves three purposes:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rapid prototyping"}),": Test control algorithms without hardware risk or cost"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Learning-based control"}),": Train neural network policies with infinite synthetic data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scenario testing"}),": Simulate rare events (collision, failure modes, edge cases)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For humanoid robotics, digital twins are critical because real robots are expensive (~$100k\u2013$500k) and real-world training is slow. Simulation enables ",(0,s.jsx)(n.strong,{children:"sim-to-real transfer"}),": train a policy in simulation, deploy to the real robot, and expect ~70\u201380% performance retention."]}),"\n",(0,s.jsx)(n.h3,{id:"the-sim-to-real-gap",children:"The Sim-to-Real Gap"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"reality gap"})," is the performance drop when a policy trained entirely in simulation is deployed to real hardware:"]}),"\n",(0,s.jsx)(n.p,{children:"Transfer Success Rate = (Real-World Performance / Simulated Performance) \xd7 100%"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Typical results (2024\u20132025):"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Grasping tasks: 71\u201385% success (sim-to-real)"}),"\n",(0,s.jsx)(n.li,{children:"Locomotion (walking): 80\u201392% success"}),"\n",(0,s.jsx)(n.li,{children:"Manipulation (reaching): 65\u201378% success"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Causes of the reality gap:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics model errors"}),": Friction coefficients, inertia tensors, contact dynamics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor noise"}),": Real IMUs drift; cameras have latency and blur"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actuation delay"}),": Motor controllers add 5\u201350 ms latency; simulation assumes instantaneous response"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unmodeled dynamics"}),": Cable routing, cable slack, motor backdrive friction"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mitigation strategy:"})," Domain randomization\u2014vary simulation parameters randomly during training so the policy learns robust behaviors invariant to parameter uncertainty."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"42-urdf-robot-models",children:"4.2 URDF Robot Models"}),"\n",(0,s.jsx)(n.h3,{id:"urdf-overview",children:"URDF Overview"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"URDF"})," (Unified Robot Description Format) is an XML-based file format that describes a robot's kinematic chain, inertial properties, collision geometry, and visual representation. URDF files are the standard in ROS 2 and Gazebo."]}),"\n",(0,s.jsx)(n.h3,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,s.jsx)(n.p,{children:"A minimal URDF has this hierarchy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'<robot name="NAME">\r\n  <link name="LINK_NAME">\r\n    \x3c!-- visual, inertial, collision properties --\x3e\r\n  </link>\r\n  <joint name="JOINT_NAME" type="TYPE">\r\n    \x3c!-- parent/child links, axis, limits --\x3e\r\n  </joint>\r\n</robot>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key elements:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Element"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Example"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<robot>"})}),(0,s.jsx)(n.td,{children:"Root container"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'<robot name="humanoid">'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<link>"})}),(0,s.jsx)(n.td,{children:"Rigid body (mass, geometry)"}),(0,s.jsx)(n.td,{children:"Base, arm, gripper"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<joint>"})}),(0,s.jsx)(n.td,{children:"Connection between links"}),(0,s.jsx)(n.td,{children:"Revolute (1-DOF), prismatic (sliding)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<inertial>"})}),(0,s.jsx)(n.td,{children:"Mass and inertia tensor"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'<mass value="2.5"/>'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<collision>"})}),(0,s.jsx)(n.td,{children:"Physics-checked shape"}),(0,s.jsx)(n.td,{children:"Simplify for speed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<visual>"})}),(0,s.jsx)(n.td,{children:"Display mesh for visualization"}),(0,s.jsx)(n.td,{children:"High-poly mesh"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<gazebo>"})}),(0,s.jsx)(n.td,{children:"Gazebo-specific properties"}),(0,s.jsx)(n.td,{children:"Material, friction coefficients"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"example-2-dof-arm-urdf",children:"Example: 2-DOF Arm URDF"}),"\n",(0,s.jsx)(n.p,{children:"Let's build a simple 2-DOF planar arm (shoulder + elbow):"}),"\n",(0,s.jsxs)(l.A,{children:[(0,s.jsx)(t.A,{value:"urdf",label:"URDF File (two_link_arm.urdf)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="two_link_arm">\r\n\r\n  \x3c!-- Define the base link (fixed to world) --\x3e\r\n  <link name="base_link">\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.1 0.1 0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.1 0.1 0.1"/>\r\n      </geometry>\r\n      <material name="grey">\r\n        <color rgba="0.5 0.5 0.5 1.0"/>\r\n      </material>\r\n    </visual>\r\n  </link>\r\n\r\n  \x3c!-- First link (shoulder to elbow) --\x3e\r\n  <link name="link_1">\r\n    <inertial>\r\n      <origin xyz="0.25 0 0"/>\r\n      <mass value="1.5"/>\r\n      \x3c!-- Inertia tensor for rod (L=0.5m, m=1.5kg) --\x3e\r\n      <inertia ixx="0.031" ixy="0.0" ixz="0.0" iyy="0.031" iyz="0.0" izz="0.001"/>\r\n    </inertial>\r\n    <collision>\r\n      <origin xyz="0.25 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.5"/>\r\n      </geometry>\r\n    </collision>\r\n    <visual>\r\n      <origin xyz="0.25 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.5"/>\r\n      </geometry>\r\n      <material name="blue">\r\n        <color rgba="0.0 0.0 1.0 1.0"/>\r\n      </material>\r\n    </visual>\r\n  </link>\r\n\r\n  \x3c!-- Second link (elbow to end-effector) --\x3e\r\n  <link name="link_2">\r\n    <inertial>\r\n      <origin xyz="0.25 0 0"/>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.021" ixy="0.0" ixz="0.0" iyy="0.021" iyz="0.0" izz="0.001"/>\r\n    </inertial>\r\n    <collision>\r\n      <origin xyz="0.25 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.04" length="0.5"/>\r\n      </geometry>\r\n    </collision>\r\n    <visual>\r\n      <origin xyz="0.25 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.04" length="0.5"/>\r\n      </geometry>\r\n      <material name="red">\r\n        <color rgba="1.0 0.0 0.0 1.0"/>\r\n      </material>\r\n    </visual>\r\n  </link>\r\n\r\n  \x3c!-- End-effector (tool frame) --\x3e\r\n  <link name="end_effector">\r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\r\n    </inertial>\r\n    <collision>\r\n      <geometry>\r\n        <sphere radius="0.02"/>\r\n      </geometry>\r\n    </collision>\r\n    <visual>\r\n      <geometry>\r\n        <sphere radius="0.02"/>\r\n      </geometry>\r\n      <material name="yellow">\r\n        <color rgba="1.0 1.0 0.0 1.0"/>\r\n      </material>\r\n    </visual>\r\n  </link>\r\n\r\n  \x3c!-- Shoulder joint (base_link to link_1) --\x3e\r\n  <joint name="shoulder_joint" type="revolute">\r\n    <parent link="base_link"/>\r\n    <child link="link_1"/>\r\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="2.0"/>\r\n    <dynamics damping="0.1" friction="0.05"/>\r\n  </joint>\r\n\r\n  \x3c!-- Elbow joint (link_1 to link_2) --\x3e\r\n  <joint name="elbow_joint" type="revolute">\r\n    <parent link="link_1"/>\r\n    <child link="link_2"/>\r\n    <origin xyz="0.5 0 0" rpy="0 0 0"/>\r\n    <axis xyz="0 0 1"/>\r\n    <limit lower="-1.57" upper="1.57" effort="8.0" velocity="2.0"/>\r\n    <dynamics damping="0.1" friction="0.05"/>\r\n  </joint>\r\n\r\n  \x3c!-- End-effector frame (link_2 to end_effector) --\x3e\r\n  <joint name="end_effector_joint" type="fixed">\r\n    <parent link="link_2"/>\r\n    <child link="end_effector"/>\r\n    <origin xyz="0.5 0 0" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Gazebo plugins for simulation --\x3e\r\n  <gazebo>\r\n    <plugin filename="ignition-gazebo-joint-controller-system" name="ignition::gazebo::systems::JointController">\r\n    </plugin>\r\n  </gazebo>\r\n\r\n</robot>\n'})})}),(0,s.jsx)(t.A,{value:"usage",label:"Load and Visualize",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Launch Gazebo with the URDF model\r\ngazebo --verbose two_link_arm.urdf\r\n\r\n# OR load with ROS 2 using robot_state_publisher\r\nros2 launch my_bot view_robot.launch.py\r\n\r\n# Inspect URDF structure\r\nurdf_to_graphviz two_link_arm.urdf > two_link_arm.gv\r\ndot -Tpng two_link_arm.gv -o two_link_arm.png\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key URDF Parameters Explained:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Meaning"}),(0,s.jsx)(n.th,{children:"Tesla Optimus Arm"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<mass>"})}),(0,s.jsx)(n.td,{children:"Link mass (kg)"}),(0,s.jsx)(n.td,{children:"1.0\u20134.0 kg per segment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<inertia ixx, iyy, izz>"})}),(0,s.jsx)(n.td,{children:"Moment of inertia (kg\u22c5m\xb2)"}),(0,s.jsxs)(n.td,{children:[(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsxs)(n.msub,{children:[(0,s.jsx)(n.mi,{children:"I"}),(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"z"}),(0,s.jsx)(n.mi,{children:"z"})]})]}),(0,s.jsx)(n.mo,{children:"="}),(0,s.jsx)(n.mn,{children:"0.001"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"I_{zz} = 0.001"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,s.jsxs)(n.span,{className:"mord",children:[(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07847em"},children:"I"}),(0,s.jsx)(n.span,{className:"msupsub",children:(0,s.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(n.span,{className:"vlist-r",children:[(0,s.jsx)(n.span,{className:"vlist",style:{height:"0.1514em"},children:(0,s.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0785em",marginRight:"0.05em"},children:[(0,s.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(n.span,{className:"mord mtight",children:(0,s.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.04398em"},children:"zz"})})})]})}),(0,s.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(n.span,{className:"vlist-r",children:(0,s.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(n.span,{})})})]})})]}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.jsx)(n.span,{className:"mrel",children:"="}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,s.jsx)(n.span,{className:"mord",children:"0.001"})]})]})]})," for thin rod"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<limit lower, upper>"})}),(0,s.jsx)(n.td,{children:"Joint angle range (rad)"}),(0,s.jsx)(n.td,{children:"\xb1\u03c0/2 typical"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<effort>"})}),(0,s.jsx)(n.td,{children:"Max torque (N\u22c5m)"}),(0,s.jsx)(n.td,{children:"2.0\u20135.0 N\u22c5m"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<velocity>"})}),(0,s.jsx)(n.td,{children:"Max angular velocity (rad/s)"}),(0,s.jsx)(n.td,{children:"1.5\u20132.5 rad/s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<damping>"})}),(0,s.jsx)(n.td,{children:"Friction coefficient"}),(0,s.jsx)(n.td,{children:"0.05\u20130.1"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"43-gazebo-simulation-environment",children:"4.3 Gazebo Simulation Environment"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Gazebo"})," (v11+, or Gazebo Ignition) is the de facto physics simulator for ROS 2 robots. It integrates:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics engines"}),": Bullet, ODE, DART (3D rigid-body dynamics)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor simulation"}),": Camera (ray-caster or GPU ray), IMU, lidar, F/T sensors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time rendering"}),": Display robot state, camera feeds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plugin system"}),": Load custom dynamics or control logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"setting-up-gazebo",children:"Setting Up Gazebo"}),"\n",(0,s.jsx)(n.p,{children:"Install Gazebo and ROS 2 integration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo apt update\r\nsudo apt install -y gazebo ros-humble-gazebo-ros\r\n\r\n# Verify installation\r\ngazebo --version\n"})}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-world-file-sdf-format",children:"Gazebo World File (SDF Format)"}),"\n",(0,s.jsxs)(n.p,{children:["Gazebo uses ",(0,s.jsx)(n.strong,{children:"SDF"})," (Simulation Description Format) for worlds. A minimal world file:"]}),"\n",(0,s.jsxs)(l.A,{children:[(0,s.jsx)(t.A,{value:"world",label:"world.sdf",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<sdf version="1.6">\r\n  <world name="humanoid_world">\r\n\r\n    \x3c!-- Physics engine configuration --\x3e\r\n    <physics name="default_physics" type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n      <gravity>0 0 -9.81</gravity>\r\n    </physics>\r\n\r\n    \x3c!-- Scene (rendering) --\x3e\r\n    <scene>\r\n      <ambient>0.4 0.4 0.4 1.0</ambient>\r\n      <background>0.7 0.7 0.7 1.0</background>\r\n      <shadows>true</shadows>\r\n    </scene>\r\n\r\n    \x3c!-- Ground plane --\x3e\r\n    <model name="ground_plane">\r\n      <static>true</static>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>0.6</mu>\r\n                <mu2>0.6</mu2>\r\n              </ode>\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <material>\r\n            <script>\r\n              <uri>file://media/materials/scripts/gazebo.material</uri>\r\n              <name>Gazebo/Grey</name>\r\n            <\/script>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Lighting --\x3e\r\n    <light name="sun" type="directional">\r\n      <cast_shadows>true</cast_shadows>\r\n      <pose>0 0 10 0 0 0</pose>\r\n      <diffuse>0.8 0.8 0.8 1</diffuse>\r\n      <specular>0.8 0.8 0.8 1</specular>\r\n      <direction>-0.5 0.1 -0.9</direction>\r\n    </light>\r\n\r\n    \x3c!-- Gazebo ROS 2 bridge plugin --\x3e\r\n    <plugin filename="ignition-gazebo-ros-init-system" name="ignition::gazebo::systems::RosInit">\r\n    </plugin>\r\n    <plugin filename="ignition-gazebo-ros-clock-system" name="ignition::gazebo::systems::RosClock">\r\n    </plugin>\r\n\r\n  </world>\r\n</sdf>\n'})})}),(0,s.jsx)(t.A,{value:"launch",label:"Launch File (launch.py)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import os\r\nfrom ament_index_python.packages import get_package_share_directory\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\n\r\ndef generate_launch_description():\r\n    gazebo_ros_dir = get_package_share_directory('gazebo_ros')\r\n\r\n    return LaunchDescription([\r\n        # Gazebo server\r\n        IncludeLaunchDescription(\r\n            PythonLaunchDescriptionSource(\r\n                os.path.join(gazebo_ros_dir, 'launch', 'gazebo.launch.py'),\r\n            ),\r\n            launch_arguments=[('world', 'world.sdf')],\r\n        ),\r\n    ])\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Physics engine tuning (ODE):"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Effect"}),(0,s.jsx)(n.th,{children:"Value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"max_step_size"})}),(0,s.jsx)(n.td,{children:"Simulation timestep (s)"}),(0,s.jsx)(n.td,{children:"0.001 (1 ms, accurate)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"real_time_factor"})}),(0,s.jsx)(n.td,{children:"Real-time ratio"}),(0,s.jsx)(n.td,{children:"1.0 (real-time), 0.5 (slower), 2.0 (faster)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"gravity"})}),(0,s.jsx)(n.td,{children:"Gravitational acceleration (m/s\xb2)"}),(0,s.jsx)(n.td,{children:"9.81 standard"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"mu"})," (friction)"]}),(0,s.jsx)(n.td,{children:"Coefficient of friction"}),(0,s.jsx)(n.td,{children:"0.6 (tile floor), 0.3 (ice)"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"44-sensor-simulation-in-gazebo",children:"4.4 Sensor Simulation in Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Real robots have noisy sensors. Gazebo simulates:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cameras"}),": RGB images, depth (lidar or stereo), semantic segmentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IMU"}),": Accelerometer + gyroscope + Gaussian noise"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"F/T sensors"}),": Force and torque at joints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encoders"}),": Joint angle feedback with quantization"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"simulating-an-imu-sensor",children:"Simulating an IMU Sensor"}),"\n",(0,s.jsxs)(l.A,{children:[(0,s.jsx)(t.A,{value:"imu_urdf",label:"IMU in URDF",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add to link in URDF --\x3e\r\n<gazebo reference="imu_link">\r\n  <sensor name="imu_sensor" type="imu">\r\n    <always_on>true</always_on>\r\n    <update_rate>200</update_rate>  \x3c!-- 200 Hz --\x3e\r\n    <visualize>false</visualize>\r\n    <topic>imu</topic>\r\n    <plugin filename="ignition-gazebo-imu-system" name="ignition::gazebo::systems::Imu">\r\n      <accel_x_noise mean="0.0" stddev="0.02"/>\r\n      <accel_y_noise mean="0.0" stddev="0.02"/>\r\n      <accel_z_noise mean="0.0" stddev="0.02"/>\r\n      <gyro_x_noise mean="0.0" stddev="0.004"/>\r\n      <gyro_y_noise mean="0.0" stddev="0.004"/>\r\n      <gyro_z_noise mean="0.0" stddev="0.004"/>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})})}),(0,s.jsx)(t.A,{value:"imu_read",label:"Read IMU (rclpy)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Imu\r\nimport numpy as np\r\n\r\nclass IMUSubscriber(Node):\r\n    def __init__(self):\r\n        super().__init__('imu_subscriber')\r\n        self.subscription = self.create_subscription(\r\n            Imu, '/imu', self.imu_callback, 10\r\n        )\r\n        self.linear_accel = np.array([0.0, 0.0, 0.0])\r\n        self.angular_vel = np.array([0.0, 0.0, 0.0])\r\n\r\n    def imu_callback(self, msg: Imu):\r\n        # Extract accelerometer data\r\n        self.linear_accel = np.array([\r\n            msg.linear_acceleration.x,\r\n            msg.linear_acceleration.y,\r\n            msg.linear_acceleration.z\r\n        ])\r\n\r\n        # Extract gyroscope data\r\n        self.angular_vel = np.array([\r\n            msg.angular_velocity.x,\r\n            msg.angular_velocity.y,\r\n            msg.angular_velocity.z\r\n        ])\r\n\r\n        self.get_logger().info(\r\n            f'Accel: {self.linear_accel}, '\r\n            f'Gyro: {self.angular_vel}'\r\n        )\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = IMUSubscriber()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"IMU Noise Model (Gaussian):"})}),"\n",(0,s.jsx)(n.p,{children:"\xe3 = a_true + N(0, \u03c3\xb2)"}),"\n",(0,s.jsx)(n.p,{children:"where \u03c3 = 0.02 m/s\xb2 (typical smartphone IMU noise)."}),"\n",(0,s.jsx)(n.h3,{id:"simulating-a-camera",children:"Simulating a Camera"}),"\n",(0,s.jsxs)(l.A,{children:[(0,s.jsx)(t.A,{value:"camera_urdf",label:"Camera in URDF",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="camera_link">\r\n  <sensor name="camera" type="camera">\r\n    <camera>\r\n      <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\r\n      <image>\r\n        <width>640</width>\r\n        <height>480</height>\r\n        <format>R8G8B8</format>\r\n      </image>\r\n      <clip>\r\n        <near>0.05</near>\r\n        <far>50.0</far>\r\n      </clip>\r\n      <noise>\r\n        <type>gaussian</type>\r\n        <mean>0.0</mean>\r\n        <stddev>0.007</stddev>  \x3c!-- Realistic camera noise --\x3e\r\n      </noise>\r\n    </camera>\r\n    <plugin filename="ignition-gazebo-camera-video-recorder-system"\r\n            name="ignition::gazebo::systems::VideoRecorder">\r\n      <video_name>camera_output</video_name>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})})}),(0,s.jsx)(t.A,{value:"camera_read",label:"Consume Camera Data",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import cv2\r\nimport numpy as np\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nfrom cv_bridge import CvBridge\r\n\r\nclass CameraSubscriber(Node):\r\n    def __init__(self):\r\n        super().__init__('camera_subscriber')\r\n        self.subscription = self.create_subscription(\r\n            Image, '/camera/image_raw', self.image_callback, 10\r\n        )\r\n        self.bridge = CvBridge()\r\n        self.latest_frame = None\r\n\r\n    def image_callback(self, msg: Image):\r\n        # Convert ROS 2 Image message to OpenCV format\r\n        self.latest_frame = self.bridge.imgmsg_to_cv2(msg, 'rgb8')\r\n\r\n        # Simple edge detection\r\n        gray = cv2.cvtColor(self.latest_frame, cv2.COLOR_RGB2GRAY)\r\n        edges = cv2.Canny(gray, 50, 150)\r\n\r\n        self.get_logger().debug(f'Frame shape: {self.latest_frame.shape}')\r\n\r\ndef main(args=None):\r\n    import rclpy\r\n    rclpy.init(args=args)\r\n    node = CameraSubscriber()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})})})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"45-sim-to-real-transfer-via-domain-randomization",children:"4.5 Sim-to-Real Transfer via Domain Randomization"}),"\n",(0,s.jsx)(n.h3,{id:"the-reality-gap-problem",children:"The Reality Gap Problem"}),"\n",(0,s.jsx)(n.p,{children:"Even with accurate physics, simulation differs from reality:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Friction coefficients"}),": Vary by surface type and wear"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mass uncertainty"}),": Actual mass \xb110% due to manufacturing tolerances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Motor backlash"}),": Small delays in real motors not modeled in perfect simulation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor latency"}),": Real cameras lag 10\u201350 ms; simulation is instantaneous"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Solution: Domain Randomization"})}),"\n",(0,s.jsxs)(n.p,{children:["Train policies with ",(0,s.jsx)(n.em,{children:"randomized"})," simulation parameters so the learned policy is robust to parameter uncertainty. At each training step, randomly sample:"]}),"\n",(0,s.jsx)(n.p,{children:"Friction ~ Uniform(0.3, 0.9)\r\nMass ~ Uniform(0.9m, 1.1m)\r\nMotor Delay ~ Uniform(0, 50 ms)"}),"\n",(0,s.jsx)(n.h3,{id:"implementation-randomize-physics-parameters",children:"Implementation: Randomize Physics Parameters"}),"\n",(0,s.jsxs)(l.A,{children:[(0,s.jsx)(t.A,{value:"randomize_urdf",label:"Python: Randomize URDF",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import xml.etree.ElementTree as ET\r\nimport random\r\nfrom typing import Dict\r\n\r\nclass URDFRandomizer:\r\n    """Randomize URDF parameters for domain randomization."""\r\n\r\n    def __init__(self, urdf_path: str):\r\n        self.tree = ET.parse(urdf_path)\r\n        self.root = self.tree.getroot()\r\n\r\n    def randomize_friction(self, min_mu: float = 0.3, max_mu: float = 0.9):\r\n        """Randomize friction coefficients for all links."""\r\n        for gazebo in self.root.findall(\'gazebo\'):\r\n            friction = gazebo.find(\'friction\')\r\n            if friction is not None:\r\n                ode = friction.find(\'ode\')\r\n                if ode is not None:\r\n                    mu = random.uniform(min_mu, max_mu)\r\n                    ode.set(\'mu\', str(mu))\r\n                    ode.set(\'mu2\', str(mu))\r\n\r\n    def randomize_mass(self, mass_scale_factor: tuple = (0.9, 1.1)):\r\n        """Randomize link masses."""\r\n        for link in self.root.findall(\'.//link\'):\r\n            inertial = link.find(\'inertial\')\r\n            if inertial is not None:\r\n                mass_elem = inertial.find(\'mass\')\r\n                if mass_elem is not None:\r\n                    original_mass = float(mass_elem.get(\'value\'))\r\n                    scale = random.uniform(*mass_scale_factor)\r\n                    new_mass = original_mass * scale\r\n                    mass_elem.set(\'value\', str(new_mass))\r\n\r\n    def randomize_motor_delay(self, max_delay_ms: float = 50.0):\r\n        """Simulate motor control delay by adding friction."""\r\n        for joint in self.root.findall(\'.//joint\'):\r\n            dynamics = joint.find(\'dynamics\')\r\n            if dynamics is not None:\r\n                # Increase damping to simulate motor lag\r\n                damping_scale = 1.0 + (max_delay_ms / 1000.0) * 0.5\r\n                old_damping = float(dynamics.get(\'damping\', 0.1))\r\n                new_damping = old_damping * damping_scale\r\n                dynamics.set(\'damping\', str(new_damping))\r\n\r\n    def save(self, output_path: str):\r\n        """Save randomized URDF to file."""\r\n        self.tree.write(output_path, encoding=\'utf-8\', xml_declaration=True)\r\n\r\n# Usage in training loop\r\ndef training_step():\r\n    """Randomize environment at each training step."""\r\n    randomizer = URDFRandomizer(\'two_link_arm.urdf\')\r\n    randomizer.randomize_friction()\r\n    randomizer.randomize_mass(mass_scale_factor=(0.9, 1.1))\r\n    randomizer.randomize_motor_delay(max_delay_ms=30)\r\n    randomizer.save(\'randomized_arm.urdf\')\r\n\r\n    # Launch Gazebo with randomized model\r\n    # ... train policy ...\n'})})}),(0,s.jsx)(t.A,{value:"randomize_sim",label:"Gazebo: Randomize World",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\r\n# randomize_world.sh - Randomize Gazebo world parameters\r\n\r\n# Generate random friction\r\nMU=$(python3 -c "import random; print(random.uniform(0.3, 0.9))")\r\n\r\n# Generate random mass multiplier\r\nMASS_SCALE=$(python3 -c "import random; print(random.uniform(0.9, 1.1))")\r\n\r\n# Generate random gravity (earth \xb1 0.5%)\r\nGRAVITY=$(python3 -c "import random; print(9.81 + random.uniform(-0.049, 0.049))")\r\n\r\n# Substitute into world.sdf template\r\nsed -e "s/<mu>.*<\\/mu>/<mu>${MU}<\\/mu>/g" \\\r\n    -e "s/<gravity>.*<\\/gravity>/<gravity>0 0 -${GRAVITY}<\\/gravity>/g" \\\r\n    world_template.sdf > world_randomized.sdf\r\n\r\n# Launch Gazebo\r\ngazebo world_randomized.sdf\n'})})})]}),"\n",(0,s.jsx)(n.h3,{id:"evaluating-sim-to-real-success",children:"Evaluating Sim-to-Real Success"}),"\n",(0,s.jsx)(n.p,{children:"After training in simulation with domain randomization, deploy to real robot and measure:"}),"\n",(0,s.jsx)(n.p,{children:"Success Rate = (# successful real-world trials) / (# total real-world trials) \xd7 100%"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Current SOTA (2024\u20132025):"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Task"}),(0,s.jsx)(n.th,{children:"Sim Success"}),(0,s.jsx)(n.th,{children:"Real Success"}),(0,s.jsx)(n.th,{children:"Transfer Rate"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Grasping (6-DoF arm)"}),(0,s.jsx)(n.td,{children:"95%"}),(0,s.jsx)(n.td,{children:"75%"}),(0,s.jsx)(n.td,{children:"79%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Object pushing"}),(0,s.jsx)(n.td,{children:"92%"}),(0,s.jsx)(n.td,{children:"74%"}),(0,s.jsx)(n.td,{children:"80%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Bin picking"}),(0,s.jsx)(n.td,{children:"88%"}),(0,s.jsx)(n.td,{children:"62%"}),(0,s.jsx)(n.td,{children:"71%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Humanoid walking"}),(0,s.jsx)(n.td,{children:"99%"}),(0,s.jsx)(n.td,{children:"87%"}),(0,s.jsx)(n.td,{children:"88%"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Humanoid running"}),(0,s.jsx)(n.td,{children:"85%"}),(0,s.jsx)(n.td,{children:"71%"}),(0,s.jsx)(n.td,{children:"84%"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Factors improving transfer:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Higher simulation fidelity (physics solver accuracy)"}),"\n",(0,s.jsx)(n.li,{children:"Wider domain randomization ranges"}),"\n",(0,s.jsx)(n.li,{children:"Real-world pretraining data (visual domain adaptation)"}),"\n",(0,s.jsx)(n.li,{children:"Reduced action/observation delays"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"46-embodiment-challenge-sim-to-real-grasping",children:"4.6 Embodiment Challenge: Sim-to-Real Grasping"}),"\n",(0,s.jsxs)(n.admonition,{title:"Challenge: Close the Reality Gap",type:"danger",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scenario:"})," You have a trained grasping policy from simulation (95% success). Deploy it to a real 6-DOF arm with parallel gripper. Initial real-world success: 58%."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Your Task:"})}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Identify gaps"})," (30 min):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Record 10 real-world failures (video + sensor logs)"}),"\n",(0,s.jsx)(n.li,{children:"Compare real joint positions vs. simulated expected positions"}),"\n",(0,s.jsx)(n.li,{children:"Measure actual friction (push object; measure acceleration vs. applied force)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Randomize simulation"})," (45 min):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create randomized friction range: [0.2, 1.2] (uniform distribution)"}),"\n",(0,s.jsx)(n.li,{children:"Add joint backlash: \xb12\xb0 per joint"}),"\n",(0,s.jsx)(n.li,{children:"Add sensor latency: 20\u201340 ms Gaussian"}),"\n",(0,s.jsx)(n.li,{children:"Retrain policy for 100k steps with randomization"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Deploy and measure"})," (20 min):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test new policy on 50 real grasps"}),"\n",(0,s.jsx)(n.li,{children:"Record success rate"}),"\n",(0,s.jsx)(n.li,{children:"Extract failure modes (finger slip, overrotation, miss)"}),"\n"]}),"\n"]}),"\n"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Success Metrics (2025 Benchmarks):"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Target"}),": 75\u201380% real-world success (industry standard)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stretch"}),": 80\u201385% (competitive)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Excellence"}),": >85% (research-grade)"]}),"\n"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Hints:"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check Tesla Optimus gripper specs: 100 N max force, 20 mm travel"}),"\n",(0,s.jsx)(n.li,{children:"Use force/torque sensor data to debug failures"}),"\n",(0,s.jsx)(n.li,{children:"Friction randomization is the highest-impact parameter"}),"\n"]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"47-references",children:"4.7 References"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sim-to-Real Transfer:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'OpenAI, "Domain Randomization for Transferring Deep Neural Networks from Simulation to the Real World," arXiv:1703.06907 (2017).'}),"\n",(0,s.jsx)(n.li,{children:'Tobin et al., "Domain Randomization and Generative Models for Robotic Grasping," arXiv:1810.10995 (2018).'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Gazebo & URDF:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Gazebo Documentation: ",(0,s.jsx)(n.a,{href:"https://gazebosim.org/docs",children:"https://gazebosim.org/docs"})]}),"\n",(0,s.jsxs)(n.li,{children:["URDF Specification: ",(0,s.jsx)(n.a,{href:"http://wiki.ros.org/urdf",children:"http://wiki.ros.org/urdf"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Physics Simulation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Erleben, K., "Stable Rigid Body Dynamics using Manifold Contact," PhD Thesis, University of Copenhagen (2005).'}),"\n",(0,s.jsxs)(n.li,{children:["Bullet Physics Engine: ",(0,s.jsx)(n.a,{href:"https://github.com/bulletphysics/bullet3",children:"https://github.com/bulletphysics/bullet3"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Domain Randomization at Scale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Peng et al., "Sim-to-Real Transfer of Robotic Control with Dynamics Randomization," ICRA 2018.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"48-rag-integration-hooks",children:"4.8 RAG Integration Hooks"}),"\n",(0,s.jsx)(n.p,{children:":::rag-query What is the difference between physics engines (ODE, Bullet, DART)?\r\nLearn which simulator to choose for your humanoid: ODE (simple, fast), Bullet (stable, accurate), DART (biomechanics-focused).\r\n:::"}),"\n",(0,s.jsx)(n.p,{children:":::rag-query How do I add custom sensors (custom tactile sensor, pressure mat) to Gazebo?\r\nExtend Gazebo with plugins to simulate non-standard sensors for specialized humanoid tasks.\r\n:::"}),"\n",(0,s.jsx)(n.p,{children:":::rag-query What causes the reality gap, and how do I measure it quantitatively?\r\nDomain randomization strategies and metrics for evaluating sim-to-real transfer success in humanoid manipulation.\r\n:::"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Concept"}),(0,s.jsx)(n.th,{children:"Key Takeaway"}),(0,s.jsx)(n.th,{children:"Application"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Digital Twin"})}),(0,s.jsx)(n.td,{children:"Virtual replica for safe, fast iteration"}),(0,s.jsx)(n.td,{children:"Train 100k+ episodes without hardware"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"URDF"})}),(0,s.jsx)(n.td,{children:"XML specification of robot structure"}),(0,s.jsx)(n.td,{children:"Load any robot into Gazebo in minutes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Gazebo Physics"})}),(0,s.jsx)(n.td,{children:"Real-time 3D rigid-body simulation"}),(0,s.jsx)(n.td,{children:"Test control algorithms pre-deployment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Sensor Simulation"})}),(0,s.jsx)(n.td,{children:"IMU, camera, F/T with realistic noise"}),(0,s.jsx)(n.td,{children:"Bridge sim-to-real gap via randomization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Domain Randomization"})}),(0,s.jsx)(n.td,{children:"Train with randomized parameters"}),(0,s.jsx)(n.td,{children:"Deploy with 70\u201380% success rate"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Next Chapter:"})," ",(0,s.jsx)(n.a,{href:"/docs/ch5-vla",children:"Chapter 5: Vision-Language-Action Systems"})," \u2014 Learn how to ground large language models (Llama 3) to humanoid action trajectories."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>t});var i=r(6540);const s={},a=i.createContext(s);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},9365:(e,n,r)=>{r.d(n,{A:()=>l});r(6540);var i=r(4164);const s={tabItem:"tabItem_Ymn6"};var a=r(4848);function l(e){var n=e.children,r=e.hidden,l=e.className;return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(s.tabItem,l),hidden:r,children:n})}}}]);