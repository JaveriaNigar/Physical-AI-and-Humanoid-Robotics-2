---
id: ch0-prerequisites
title: "Prerequisites & Notation"
sidebar_label: "Prerequisites"
description: "Mathematical notation, assumed knowledge, and quick refresher on linear algebra and physics concepts used throughout the textbook."
---

## Prerequisites & Notation Guide

This page provides a quick reference for mathematical notation and concepts used throughout the textbook. If you're already comfortable with linear algebra and classical mechanics, feel free to skip.

### Part 1: Mathematical Notation

#### Linear Algebra

**Vectors** (lowercase bold or with arrow):

$$\mathbf{v} = \begin{bmatrix} v_x \\ v_y \\ v_z \end{bmatrix}, \quad |\mathbf{v}| = \sqrt{v_x^2 + v_y^2 + v_z^2}$$

**Matrices** (uppercase bold):

$$\mathbf{M} = \begin{bmatrix} m_{11} & m_{12} \\ m_{21} & m_{22} \end{bmatrix}$$

**Dot Product** (vector-vector):

$$\mathbf{u} \cdot \mathbf{v} = u_x v_x + u_y v_y + u_z v_z = |\mathbf{u}||\mathbf{v}|\cos\theta$$

**Cross Product** (vector × vector → vector):

$$\mathbf{u} \times \mathbf{v} = \begin{bmatrix} u_y v_z - u_z v_y \\ u_z v_x - u_x v_z \\ u_x v_y - u_y v_x \end{bmatrix}$$

**Matrix Multiplication**:

$$(\mathbf{A}\mathbf{B})_{ij} = \sum_k a_{ik}b_{kj}$$

**Transpose** (flip rows/columns):

$$\mathbf{A}^T_{ij} = \mathbf{A}_{ji}$$

**Inverse** (reverse operation):

$$\mathbf{A}\mathbf{A}^{-1} = \mathbf{I}$$ (identity matrix)

**Determinant** (2×2 example):

$$\det\begin{bmatrix} a & b \\ c & d \end{bmatrix} = ad - bc$$

#### Calculus

**Derivative** (rate of change):

df/dx = lim(Δx → 0) [f(x + Δx) - f(x)] / Δx

**Partial Derivative** (multi-variable):

∂f/∂x = derivative with respect to x (holding other variables constant)

**Gradient** (vector of partial derivatives):

∇f = [∂f/∂x, ∂f/∂y, ∂f/∂z]ᵀ

**Integral** (area under curve):

$$\int_a^b f(x)\,dx$$

**Differential Equations** (rate of change equation):

dq/dt = q̇ = velocity

d²q/dt² = q̈ = acceleration

#### Rotations (Special to Robotics)

**Rotation Matrix** (3×3 orthogonal matrix):

$$\mathbf{R} \in SO(3), \quad \mathbf{R}^T\mathbf{R} = \mathbf{I}, \quad \det(\mathbf{R}) = 1$$

Rotation around z-axis by angle $\theta$:

$$\mathbf{R}_z(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

**Homogeneous Transformation** (rotation + translation):

$$\mathbf{T} = \begin{bmatrix} \mathbf{R} & \mathbf{p} \\ 0 & 1 \end{bmatrix} \in SE(3)$$

where $\mathbf{R}$ is rotation and $\mathbf{p}$ is position.

**Euler Angles** (roll, pitch, yaw):

$$(\alpha, \beta, \gamma) \rightarrow \mathbf{R}_z(\gamma)\mathbf{R}_y(\beta)\mathbf{R}_x(\alpha)$$

---

### Part 2: Physics Concepts

#### Kinematics (Motion without forces)

**Position** ($\mathbf{p}$ or $\mathbf{r}$): Where something is.

p(t) = [x(t), y(t), z(t)]ᵀ

**Velocity** (v or ṗ): Rate of position change.

v(t) = dp/dt = ṗ(t)

**Acceleration** (a or p̈): Rate of velocity change.

a(t) = dv/dt = p̈(t)

**Angular Velocity** (ω): How fast something rotates (rad/s).

ω = dθ/dt

**Angular Acceleration** (α): Rate of angular velocity change.

α = dω/dt

#### Dynamics (Forces cause motion)

**Force** ($\mathbf{F}$): Push or pull (Newtons, N).

**Newton's Second Law**:

$$\mathbf{F} = m\mathbf{a}$$

**Torque** (τ): Rotational force (N⋅m).

$$\tau = \mathbf{r} \times \mathbf{F}$$

**Moment of Inertia** ($I$): Resistance to rotation (kg⋅m²).

For a rod rotating about its center:

$$I = \frac{1}{12}mL^2$$

For a point mass at distance $r$:

$$I = mr^2$$

**Rotational Dynamics** (like F = ma for rotation):

$$\boldsymbol{\tau} = I\boldsymbol{\alpha}$$

#### Energy

**Kinetic Energy** (energy of motion):

$$E_k = \frac{1}{2}mv^2 + \frac{1}{2}I\omega^2$$

**Potential Energy** (energy of position):

$$E_p = mgh$$

where $h$ is height.

**Work** (force × distance):

$$W = \mathbf{F} \cdot \mathbf{d} = Fd\cos\theta$$

**Power** (work per time):

$$P = \frac{dW}{dt}$$

---

### Part 3: Robotics-Specific Notation

#### Joint Representation

**Joint Angles** (generalized coordinates):

$$\mathbf{q} = \begin{bmatrix} q_1 \\ q_2 \\ \vdots \\ q_n \end{bmatrix} \quad \text{(n degrees of freedom)}$$

**Joint Velocities**:

$$\dot{\mathbf{q}} = \frac{d\mathbf{q}}{dt} = \begin{bmatrix} \dot{q}_1 \\ \vdots \\ \dot{q}_n \end{bmatrix}$$

**Joint Torques** (what motors apply):

$$\boldsymbol{\tau} = \begin{bmatrix} \tau_1 \\ \vdots \\ \tau_n \end{bmatrix}$$

#### Manipulator Equation

**Full dynamics of a robot arm:**

$$\boldsymbol{\tau} = \mathbf{M}(\mathbf{q})\ddot{\mathbf{q}} + \mathbf{C}(\mathbf{q}, \dot{\mathbf{q}})\dot{\mathbf{q}} + \mathbf{g}(\mathbf{q})$$

where:
- $\mathbf{M}(\mathbf{q})$: Mass/inertia matrix (n×n)
- $\mathbf{C}(\mathbf{q}, \dot{\mathbf{q}})$: Coriolis and centrifugal terms
- $\mathbf{g}(\mathbf{q})$: Gravity vector

#### Denavit-Hartenberg (DH) Parameters

Standard way to represent robot kinematics:

| Parameter | Meaning |
|-----------|---------|
| $a_i$ | Link length (distance along x-axis) |
| $\alpha_i$ | Link twist (rotation around x-axis) |
| $d_i$ | Link offset (distance along z-axis) |
| $\theta_i$ | Joint angle (rotation around z-axis) |

---

### Part 4: Programming Notation

#### NumPy / Python

```python
import numpy as np

# Vector
v = np.array([1, 2, 3])  # [v_x, v_y, v_z]

# Matrix
M = np.array([[1, 2], [3, 4]])

# Dot product
u @ v  # or np.dot(u, v)

# Matrix multiplication
M @ v  # or np.dot(M, v)

# Transpose
M.T

# Inverse
np.linalg.inv(M)

# Determinant
np.linalg.det(M)

# Norm (magnitude)
np.linalg.norm(v)

# Derivative (numerical)
dq_dt = np.diff(q) / np.diff(t)
```

#### ROS 2 Message Types

```python
# Geometry
geometry_msgs.Point: x, y, z
geometry_msgs.Quaternion: x, y, z, w  (rotation)
geometry_msgs.Twist: linear (v_x, v_y, v_z), angular (ω_x, ω_y, ω_z)

# Sensor
sensor_msgs.JointState: name, position (q), velocity (ḋq), effort (τ)
sensor_msgs.Imu: linear_acceleration, angular_velocity, orientation
sensor_msgs.Image: data (pixel array), encoding (e.g., "rgb8")

# Control
trajectory_msgs.JointTrajectory: points (q(t) over time)
```

---

### Part 5: Assumed Knowledge

#### Math You Should Know

- **Vectors and matrices**: Addition, multiplication, transpose
- **Linear systems**: $\mathbf{Ax} = \mathbf{b}$ (solve for $\mathbf{x}$)
- **Derivatives and integrals**: Basic calculus
- **Trigonometry**: sin, cos, tan, inverse functions
- **Complex numbers** (optional): $e^{i\theta} = \cos\theta + i\sin\theta$ (Chapter 3+)

#### Physics You Should Know

- **Newton's laws**: $\mathbf{F} = m\mathbf{a}$
- **Energy conservation**: $E_k + E_p = \text{const}$
- **Rotations**: How things spin
- **Friction**: Sliding and rolling resistance

#### Programming You Should Know

- **Python basics**: Variables, functions, loops, conditionals
- **NumPy**: Vectors, matrices, operations
- **Plotting**: matplotlib for visualizations
- **File I/O**: Read/write data (JSON, YAML, CSV)

---

### Part 6: Quick Refresher

If you're rusty on any of these, here are quick examples:

#### Dot Product (Similarity)

```python
import numpy as np

u = np.array([1, 0])
v = np.array([1, 1])

# Dot product
dot = u @ v  # = 1*1 + 0*1 = 1

# Angle between vectors
norm_u = np.linalg.norm(u)  # = 1
norm_v = np.linalg.norm(v)  # = √2
cos_angle = dot / (norm_u * norm_v)  # = 1/√2
angle = np.arccos(cos_angle)  # ≈ 45°
```

#### Rotation Matrix (Transform a point)

```python
# Rotate point (1, 0, 0) by 90° around z-axis
theta = np.pi / 2
R = np.array([
    [np.cos(theta), -np.sin(theta), 0],
    [np.sin(theta), np.cos(theta), 0],
    [0, 0, 1]
])

p = np.array([1, 0, 0])
p_rotated = R @ p  # ≈ [0, 1, 0]
```

#### Inverse Kinematics (Approximate)

```python
from scipy.optimize import minimize

def forward_kinematics(q):
    """Given joint angles q, compute end-effector position."""
    x = np.cos(q[0]) + np.cos(q[0] + q[1])
    y = np.sin(q[0]) + np.sin(q[0] + q[1])
    return np.array([x, y])

def inverse_kinematics(target):
    """Find joint angles for target position."""
    def error(q):
        ee_pos = forward_kinematics(q)
        return np.sum((ee_pos - target)**2)

    # Optimize
    result = minimize(error, x0=np.zeros(2))
    return result.x

# Example: reach to (1.5, 0.5)
q_solution = inverse_kinematics(np.array([1.5, 0.5]))
print(q_solution)
```

---

### Part 7: Getting Help

**If you get stuck on notation:**

1. Check the **notation reference** above
2. Consult [3Blue1Brown's Essence of Linear Algebra](https://www.3blue1brown.com/topics/linear-algebra) (YouTube)
3. Review a physics refresher on [Khan Academy](https://www.khanacademy.org/)
4. Ask in the [PIAIC Discord](https://discord.gg/piaic) or [ROS Discourse](https://discourse.ros.org)

**If you get stuck on a concept:**

1. Re-read the chapter (sometimes second reading clicks)
2. Watch the embedded Embodiment Challenge videos
3. Run the code examples yourself
4. Modify parameters and see what happens (best way to learn!)

---

### Ready?

You now have the notation and concepts you need. Let's begin!

**Next**: [Chapter 1: Introduction to Physical AI →](/docs/ch1-intro)
