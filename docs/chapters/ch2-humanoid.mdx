---
id: ch2-humanoid
title: "Chapter 2: Basics of Humanoid Robotics"
sidebar_label: "Ch2: Humanoid Basics"
description: "Kinematics, dynamics, actuators, and sensing—the engineering fundamentals of humanoid robots. Practical calculations for reaching, grasping, and movement."
keywords: ["kinematics", "dynamics", "actuators", "dof", "energy efficiency", "forward kinematics", "inverse kinematics", "sensors", "imu", "force sensors"]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Chapter 2: Basics of Humanoid Robotics

## Learning Objectives

:::info
After this chapter, you will:

- **Understand** forward and inverse kinematics: computing robot end-effector position from joint angles, and vice versa
- **Apply** the manipulator equation: $\tau = M(q)\ddot{q} + C(q,\dot{q})\dot{q} + g(q)$ to analyze forces and torques
- **Design** actuators for specific tasks: motor selection, gear ratios, compliance trade-offs
- **Integrate** sensors for proprioception and exteroception: encoders, IMU, force/torque sensors
- **Optimize** energy efficiency: battery constraints, trajectory planning for humanoid robots
- **Run Python code** to compute kinematics and control simulated robots
:::

---

## 2.1: Kinematics—From Joints to Position

### What is Kinematics?

**Kinematics** is the study of motion without considering forces or masses. It answers: *"If I move joint 1 by 30°, where does my end-effector (hand/gripper) end up?"*

For a humanoid robot, this is fundamental:
- **Forward kinematics**: Given joint angles $\theta$, compute end-effector position $\mathbf{p}$
- **Inverse kinematics (IK)**: Given desired position $\mathbf{p}$, find required joint angles $\theta$

### Forward Kinematics: Theory

For a chain of rigid links connected by revolute joints (like an arm), we use **homogeneous transformations**:

$$T = \begin{bmatrix} R & \mathbf{p} \\ 0 & 1 \end{bmatrix}$$

where:
- $R \in SO(3)$: 3×3 rotation matrix
- $\mathbf{p} \in \mathbb{R}^3$: 3D position vector

The transformation between consecutive frames follows the **Denavit-Hartenberg (DH) convention**:

$$T_i^{i-1} = \text{Rz}(q_i) \cdot \text{Tz}(d_i) \cdot \text{Tx}(a_i) \cdot \text{Rx}(\alpha_i)$$

For a 2-DOF planar arm (simpler case):

$$x = L_1 \cos(q_1) + L_2 \cos(q_1 + q_2)$$
$$y = L_1 \sin(q_1) + L_2 \sin(q_1 + q_2)$$

### Forward Kinematics: Code Example

<Tabs>
<TabItem value="python" label="Python (Forward Kinematics)">

```python
import numpy as np
import matplotlib.pyplot as plt

def forward_kinematics_2dof(q1, q2, L1=1.0, L2=0.5):
    """
    Forward kinematics for 2-DOF planar arm.

    Args:
        q1, q2: Joint angles (radians)
        L1, L2: Link lengths (meters)

    Returns:
        ee_pos: End-effector position [x, y]
        joint_2_pos: Position of joint 2 [x, y]
    """
    # First joint contributes
    x1 = L1 * np.cos(q1)
    y1 = L1 * np.sin(q1)

    # Second joint contributes
    x2 = x1 + L2 * np.cos(q1 + q2)
    y2 = y1 + L2 * np.sin(q1 + q2)

    return np.array([x2, y2]), np.array([x1, y1])

# Test: Visualize reachable workspace
fig, ax = plt.subplots(figsize=(8, 8))

# Sample joint angles
q1_vals = np.linspace(0, 2*np.pi, 30)
q2_vals = np.linspace(0, 2*np.pi, 30)

for q1 in q1_vals[::3]:  # Sample every 3rd
    for q2 in q2_vals[::3]:
        ee_pos, j2_pos = forward_kinematics_2dof(q1, q2)
        ax.plot(ee_pos[0], ee_pos[1], 'b.', markersize=3)

ax.set_xlim([-2, 2])
ax.set_ylim([-2, 2])
ax.set_aspect('equal')
ax.grid(True, alpha=0.3)
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_title('2-DOF Arm Workspace (Blue dots = reachable positions)')
plt.show()

# Verify a specific configuration
q1_test, q2_test = np.pi/4, np.pi/6
ee_pos, j2_pos = forward_kinematics_2dof(q1_test, q2_test)
print(f"q1={np.degrees(q1_test):.0f}°, q2={np.degrees(q2_test):.0f}°")
print(f"End-effector: ({ee_pos[0]:.3f}, {ee_pos[1]:.3f})")
```

</TabItem>
</Tabs>